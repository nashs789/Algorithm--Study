# **[ 정보 ]**
1. 소요 시간: 24분
2. 날짜: 2023.04.06(목)
3. 저자: 이 인복
4. 난이도: BaekJoon (Bronze 2)
5. 분류: Brute Force
6. 문제: 분해합

# **[ 문제 설명 ]**
<img width="1148" alt="스크린샷 2023-04-06 오전 12 54 05" src="https://user-images.githubusercontent.com/59809278/230136524-ddcc82db-7a46-4edc-992e-4adc5aaf1559.png">

어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.  
어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다.   
예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다.  
따라서 245는 256의 생성자가 된다.  
물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다.   
반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.

# **[ 입력 ]**
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

# **[ 출력 ]**
첫째 줄에 답을 출력한다.   
생성자가 없는 경우에는 0을 출력한다.

# **[ 예제 입력 #1 ]**
    216

# **[ 예제 출력 #1 ]**
    198

# **[ 접근 순서 ]**
1. 1부터 어디까지 반복해야 하는가?
    - 탈출문의 조건은?
   

2. 생성자가 없는 케이스는?
    - ex) 자연수가 1일 때
    - 생성자가 한 번도 갱신되지 않았다면 생성자가 없다고 판단
    

3. 문자열이 아닌 사칙연산을 이용
    - 문자열로 계산하면 효율이 떨어질 것으로 보임(잦은 캐스팅 혹은 문자열 연산 메소드 이용)
    - 사칙연산보다 효율을 높이려면 비트연산
    
# **[ 문제점 ]**
1. break; 문 추가로 조금의 시간적인 효율 상승
    - 맨 처음 찾게되는 생성자가 0부터 시작하기 때문에 가장 최소 값으로 추정할 수 있음

# **[ 새로 알게된 사실 ]**

# **[ 결과 ]**
<img width="1148" alt="스크린샷 2023-04-06 오전 12 54 14" src="https://user-images.githubusercontent.com/59809278/230136545-e132e802-88ef-48b1-9cf1-3f357ef9eefe.png">

