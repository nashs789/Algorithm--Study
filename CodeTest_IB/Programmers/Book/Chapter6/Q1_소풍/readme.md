# **[ 정보 ]**
1. 소요 시간: 10시간 이상 걸린듯 ㅋㅋㅋㅋㅋㅋ
2. 날짜: 2023.03.14(화)
3. 저자: 이 인복
4. 난이도: Easy
5. 분류: Brute Force 추정(몰?루)
6. 문제: 소풍(p.155)

# **[ 시간 및 메모리 제한 ]**
프로그램은 1초내에 실행 되어야 하고, 64MB 이하의 메모리만을 사용해야 합니다.

# **[ 문제 설명 ]**
안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다.  
원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다.  
그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 항상 서로 친구인 학생들끼리만 짝을 지어야 합니다.  
각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝 지을 수 있는 방법의 수를 계산하는 프로그램을 작성하세요.  
짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다.  
예를 들어 다음 두 가지 방법은 서로 다른 방법입니다.

- ex1) [태연, 제시카] [써니, 티파니] [효연, 유리]
- ex2) [태연, 제시카] [써니 유리] [효연, 티파니]

# **[ 입력 ]**
- 입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다.
- 각 테스트 케이스의 첫 줄에는 학생의 수 n(2 <= n <= 10)과 친구 쌍의 수 m(0 <= m <= n(n - 1) / 2) 이 주어집니다.
- 그 다음 줄에 m개의 정수 쌍으로 서로 친구인 두 학생의 번호가 주어집니다.
- 번호는 모두 0부터 n-1 사이의 정수이고, 같은 쌍은 입력에 두 번 주어지지 않습니다.
- 학생들의 수는 짝수 입니다.

# **[ 출력 ]**
- 각 테스트 케이스마다 한 줄에 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력합니다.

# **[ 예제 입력 1 ]**
      3
      2 1
      0 1
      4 6
      0 1 1 2 2 3 3 0 0 2 1 3
      6 10
      0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5

# **[ 예제 출력 1 ]**
      1
      3
      4

# **[ 예제 입력 2 ]**
      1
      10 81
      0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 1 0 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0 2 1 2 3 2 4 2 5 2 6 2 7 2 8 2 9 3 0 3 1 3 2 3 4 3 5 3 6 3 7 3 8 3 9 4 0 4 1 4 2 4 3 4 5 4 6 4 7 4 8 4 9 5 0 5 1 5 2 5 3 5 4 5 6 5 7 5 8 5 9 6 0 6 1 6 2 6 3 6 4 6 5 6 7 6 8 6 9 7 0 7 1 7 2 7 3 7 4 7 5 7 6 7 8 7 9 8 0 8 1 8 2 8 3 8 4 8 5 8 6 8 7 8 9 9 0 9 1 9 2 9 3 9 4 9 5 9 6 9 7 9 8

# **[ 예제 출력 2 ]**
      945

# **[ 접근 순서 ]**
1. 재귀함수를 사용 or 일반적인 반복문
    - 반복문: 첫 시도로 반복문으로 하려 했는데 모든 경우의 수를 단순 반복문으로 찾는게 쉽지 않았음
    - 재귀함수: 지금까지 기피해온 알고리즘으로 드디어 첫 발걸음을 할 때가 옴을 느꼈음


2. 어떻게 짝지어 줄 것인가?
    - boolean pairs[] 를 통해서 짝이 맺어진 친구들은 true 처리 후 다음 재귀함수로 넘기는 방식 사용
    - 짝이 안지어진 친구들만 지어주면 됨


3. 짝이 중복되서 나타나는 현상은 어떻게 처리할 것인가? (가장 중요 하다고 생각되는 항목)
    1. 짝이 지어질 때 친구들의 번호를 문자열로 남김
        - ex) 0 1(짝) 2 3(짝) 4 5(짝) 이렇게 3쌍의 짝이 있는경우 3개의 문자열이 존재
    2. 문자열들을 HashSet 에 저장
    3. 모든 짝이 맺어진 경우 문자열 앞에 위치한 수를 기준으로 오름차순 정렬
        - ex) 0 1 -> 0 을 기준으로 정렬
    4. 정렬된 요소들의 문자열을 전부 '+' 연산으로 더해줌
    5. 짝이 맺어진 경우들을 Set<String> totalPair 에 저장하고 있다가 저장되어 있지 않은 케이스가 나오면 카운트 증가

# **[ 문제점 & 주의점 ]**
- 코드가 주어진 예시만 보고 해서 다른 테스트 케이스가 틀릴거라고 확인이 드는중...ㅠㅡㅠ (답지 보고 다른 풀이 예정)
  근데 더 못풀겠음 진짜...
  - plus) 문자열 연산이 많고, 계속해서 새로운 객체를 생성하기 때문에 메모리와 시간에 대한 제한조건도 충족하지 못할거 같음..(확인하기 무서움) ===> 좋지 않은 풀이 방법 이였던 것 같다

- 도대체 어떻게 이게 난이도 '하' 인지 너무 화가나고, 무력함..

# **[ 새로 알게된 사실 ]**

# **[ 결과 ]**
<img width="358" alt="스크린샷 2023-03-14 오전 12 45 14" src="https://user-images.githubusercontent.com/59809278/224754367-e53814f1-11b4-4c1c-9a63-3eedb990afab.png">

[ 정상동작 하는지 궁금해서 10명의 친구가 전부 친구일 때 케이스로 시험 해봄 ]
<img width="1801" alt="스크린샷 2023-03-15 오후 11 56 36" src="https://user-images.githubusercontent.com/59809278/225349326-1ea72d4c-507d-4ce4-93f7-33df614cbf2d.png">

