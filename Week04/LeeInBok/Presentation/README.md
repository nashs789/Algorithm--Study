# **[ 변수 ]**
- 컴파일 시 메모리 주소에 위치하고, 기계어가 메모리 값에서 읽어온다.
- 메모리는 OS가 관리한다.
- 32bit 프로그램은 64bit 운영체제에서 동작 하지만 반대는 불가능
- 64bit 의 장점은?
    - 동시 처리능력 높음(한 번에 처리 가능한 용량이 큼)
    - RAM 을 16EB(2^60) 까지 사용 가능하다.
- 64bit 의 단점은?
    - 메모리 비효율 (1Byte 데이터를 처리 하려고 해도 많은 메모리를 사용 해야함)
    - 4GB(2^32)
    - 32bit 프로그램은 호환성을 돕는 모듈도 설치 및 관리가 필요함

### **[ 메모리 주소 지정 방식 ]**
- 1Byte 단위로 관리된다.
- 32bit 기준 0 ~ 2^32 -1 만큼의 메모리 주소 사용 가능
- 반드시 메모리 주소를 지정해야 사용 가능하다.
- 한 번에 읽거나 저장할 메모리 크기를 지정해야함

![KakaoTalk_Photo_2023-09-01-19-45-43](https://github.com/nashs789/JGAlgo/assets/59809278/a5d857d3-1626-430e-80e3-39c585ecc5c3)

### **[ 직접 주소 지정 방식의 한계 ]**
- 다른 함수에 존재하는 변수 참조 불가능(지역 변수)
    - 메모리 상에서는 주변에 존재하는 것처럼 보이지만 코드에서 알 수가 없음
- 파라미터로 어느정도 극복은 가능
    - 하지만 함수 내에서 파라미터의 값도 변경하고 싶다면?
- return 의 한계 (1개만 return 가능)
    - 여러개의 변수를 변경하고 싶다면?

# **[ 포인터 (Pointer) ]**
- point + er => 가르킨다
    - 무엇을? 메모리 주소를 저장하여, 해당 메모리 주소를 가르킨다.
- C 언어에서의 간접 주소 지정 방식이다.
- 자료형 선언하지 않아도 무조건 4 Byte 의 메모리를 갖는다. (주소 값을 저장하기 때문)
- 메모리 주소를 직접 할당하는것이 아닌 운영체제를 통해서 할당 받는다. ===> 직접 지정한 메모리에 어떤 정보가 있는지 모르기 때문에 
- 포인터 관련 연산자
  - *(Asterisk - 간접 참조 연산자): 포인터 변수 선언 시 와 찰조할 때 역할이 다름을 기억한다.
  - & (주소 연산자 - 단항 연산자): 피연산자의 주소를 반환한다.
  - %p(메모리 출력 - 지시 연산자): 메모리 주소 출력을 위해 사용되는 지시자.

        ⚙︎ Example for 선언
        short *ptr => short: 자료형 (포인터가 저장하고 있는 주소 값에서 작업할 메모리의 크기)
                   => *    : 포인터임을 명시
                   => ptr  : 포인터 변수의 이름

        ⚙︎ Example for 사용법
        short a;
        short *p;
        p = &a;
        printf("%p\n", p)

        [ console ]
        0x16b36f3da

![사진1](https://github.com/nashs789/JGAlgo/assets/59809278/6120afe7-3464-4b3b-a70e-a635d793b729)

1. 0x66에서 참조할(저장된) 주소를 확인한다.
2. 0x6C로 이동해서 2Byte 만큼의 크기에서 작업한다.
    - 포인터 변수 p의 자료형이 short 이기 때문에
    - 정확히는 포인터 변수의 자료형이 아니고, 작업할 메모리의 용량임

### **[ 직접 접근하는 대신에 간접 접근하는 이유? ]**
- 함수 내에서는 다른 함수와 지역 변수를 참조하거나 값을 변경하는게 불가능 한데 포인터를 사용하게 되면 참조 및 변경이 가능해진다.
- 가장 흔한 예시로 swap 함수가 있음
- 데이터 타임을 명시적으로 확정할 수 없는 케이스


    ⚙︎ Example for 함수에서의 접근
    [ 호출부 ]
    int a = 5;
    callFunc(&a)

    [ 함수 선언 ]
    void callFunc(int *a){
        함수 내용
    }

### **[ 주소 변경을 막을 수 있다 (포인터 상수) ]**
- 포인터 연산을 할다가 실수를 방지하기 위해서 상수로 선언하여 저장된 주소 값에 대한 변경을 방지할 수 있다.

      int * a   ===> 변경의 여지가 다분함
      int * const a    ===> 포인터가 저장한 주소 값을 변경할 수 없도록 한다. ex) p = &temp (Error)
      const int * const a    ===> 포인터가 가르키고 있는 대상의 값을 변경하지 못하도록 한다. ex) *p = 3

### **[ 사용할 메모리 범위 산정 방법 ]**
1. 시작과 끝 주소를 기억한다. (Required 8Byte)
2. 시작 주소와 사용할 크기를 기억한다. (Required 4Byte) ===> C 언어의 포인터 방식

        ⚙︎ int *p
        - int: 대상의 크기(얼마나 & 어떻게)
        - *p : 시작 주소
        
        ⚙ example for 1Byte 단위로 확인
        int data = 0x12345678;
        int idx;
        char *p = (char *) &data;   ===> 포인터 형변환
     
        for(idx = 0; idx < 4; idx++){
            printf("%X\n", (p + idx));    ===> 포인터 주소 연산
        }

        [ console ] 
        6B26B3D0
        6B26B3D2
        6B26B3D4
        6B26B3D6
        
### **[ 포인터 변수의 주소 연산 ]**

    short data = 0
    short *p = &data
    p = p + 1

![KakaoTalk_Photo_2023-09-01-19-45-38](https://github.com/nashs789/JGAlgo/assets/59809278/5091b6fb-bfee-4d74-ae5d-b6d96c0bd491)

### **[ void * (= 정해지지 않았다.) ]**
- 가르키는 대상의 크기를 모를 때
- 사용할 메모리의 시작 주소만 알고 끝 주소는 모를 때
  
        ⚙ example for 사용법
        int data = 0
        void *p = &data
        *p = 5 ===> Error (대상의 메모리가 미지정이라 타입 추론이 불가능)
        *(int*) p = 5 ===> Casting 하여 사용 한다.
        

- 언제 사용할까?
    - 크기(메모리) 지정을 뒤로 미룰 때
    
           ⚙︎ example for void pointer
           
           - void pointer를 사용하지 않는 케이스
           [ 호출 ]
           func(Null, &data, Null)         

           [ 함수 ]
           func(char *a, short *b, int *c){
               if 문 분기를 통해서 Null 인지 확인하고, 캐스팅 후 사용 
           }
    
           - void pointer를 사용하는 케이스
           [ 호출 ]
           func(void *p, char flag){
               if 문 분기를 통해서 flag 확인 후 맞는 타임으로 캐스팅 후 사용
               ex) flag ===> 1: char, 2: short, 3: int 
           }          
