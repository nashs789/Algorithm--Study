# **[ 정보 ]**
1. 소요 시간: 27분
   - sol1 측정 시간
   - sol2는 다른 사람의 알고리즘 연습
2. 날짜: 2023.03.28(화)
3. 저자: 이 인복
4. 난이도: BaekJoon (Silver 3)
5. 분류: BackTracking
6. 문제: N과 M(1)

# **[ 문제 설명 ]**
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
# **[ 입력 ]**
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)
# **[ 출력 ]**
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.   
중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.
# **[ 예제 입력 #1 ]**
    3 1
# **[ 예제 출력 #1 ]**
    1
    2
    3
# **[ 예제 입력 #2 ]**
    4 2
# **[ 예제 출력 #2 ]**
    1 2
    1 3
    1 4
    2 1
    2 3
    2 4
    3 1
    3 2
    3 4
    4 1
    4 2
    4 3
# **[ 예제 입력 #3 ]**
    4 4
# **[ 예제 출력 #3 ]**
    1 2 3 4
    1 2 4 3
    1 3 2 4
    1 3 4 2
    1 4 2 3
    1 4 3 2
    2 1 3 4
    2 1 4 3
    2 3 1 4
    2 3 4 1
    2 4 1 3
    2 4 3 1
    3 1 2 4
    3 1 4 2
    3 2 1 4
    3 2 4 1
    3 4 1 2
    3 4 2 1
    4 1 2 3
    4 1 3 2
    4 2 1 3
    4 2 3 1
    4 3 1 2
    4 3 2 1

# **[ 접근 순서 ]**
1. sol1: 내가 맨 처음 문제를 봤을 때 타인의 풀이 없이 혼자서 생각한 알고리즘

2. sol2: 타인의 코드중 효율이 좋은 코드

# **[ 문제점 & 주의점 ]**
[ sol1의 문제점 ]
- String 연산
  - StringBuilder로 대체 가능
- new 연산
  - Arrays.copyOf 로 만들어지는 객체 말하는 것
- 정렬
  - 재귀로 1부터 순회하면 정렬할 필요가 없음

다른 알고리즘에는 들어가지 않는 로직이 들어가 효율이 많이 차이나게 된다.

# **[ 새로 알게된 사실 ]**
다른 사람의 코드를 보니까 재귀함수라 그런지 이해하는데 더 어려움을 겪음
   - 되게 잘 짜여진 코드임을 느낌

# **[ 결과 ]**


