# **[ 정보 ]**
1. 소요 시간: 4시간 33분
    - Sol1) 1시간 16분
    - Sol2) 1시간 38분
    - Sol3) 1시간 39분
2. 날짜: 2023.06.03(토)
3. 저자: 이 인복
4. 난이도: BaekJoon (Gold 2)
5. 분류: Dijkstra
6. 문제: 미확인 도착지

# **[ 문제 설명 ]**

<img width="1153" alt="스크린샷 2023-06-03 오후 2 49 11" src="https://github.com/nashs789/CodeTest/assets/59809278/fec40805-027d-415c-852e-ff06ecb289e2">

(취익)B100 요원, 요란한 옷차림을 한 서커스 예술가 한 쌍이 한 도시의 거리들을 이동하고 있다.   
너의 임무는 그들이 어디로 가고 있는지 알아내는 것이다.   
우리가 알아낸 것은 그들이 s지점에서 출발했다는 것, 그리고 목적지 후보들 중 하나가 그들의 목적지라는 것이다.   
그들이 급한 상황이기 때문에 목적지까지 우회하지 않고 최단거리로 갈 것이라 확신한다. 이상이다. (취익)

어휴! (요란한 옷차림을 했을지도 모를) 듀오가 어디에도 보이지 않는다.   
다행히도 당신은 후각이 개만큼 뛰어나다.   
이 후각으로 그들이 g와 h 교차로 사이에 있는 도로를 지나갔다는 것을 알아냈다.

이 듀오는 대체 어디로 가고 있는 것일까?

<img width="1153" alt="스크린샷 2023-06-03 오후 2 49 32" src="https://github.com/nashs789/CodeTest/assets/59809278/8b4e1eee-7986-4165-9262-6909b9513303">

예제 입력의 두 번째 케이스를 시각화한 것이다. 이 듀오는 회색 원에서 두 검은 원 중 하나로 가고 있고 점선으로 표시된 도로에서 냄새를 맡았다. 따라서 그들은 6으로 향하고 있다.

# **[ 입력 ]**
첫 번째 줄에는 테스트 케이스의 T(1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스마다

- 첫 번째 줄에 3개의 정수 n, m, t (2 ≤ n ≤ 2 000, 1 ≤ m ≤ 50 000 and 1 ≤ t ≤ 100)가 주어진다. 각각 교차로, 도로, 목적지 후보의 개수이다.
- 두 번째 줄에 3개의 정수 s, g, h (1 ≤ s, g, h ≤ n)가 주어진다. s는 예술가들의 출발지이고, g, h는 문제 설명에 나와 있다. (g ≠ h)
- 그 다음 m개의 각 줄마다 3개의 정수 a, b, d (1 ≤ a < b ≤ n and 1 ≤ d ≤ 1 000)가 주어진다. a와 b 사이에 길이 d의 양방향 도로가 있다는 뜻이다.
- 그 다음 t개의 각 줄마다 정수 x가 주어지는데, t개의 목적지 후보들을 의미한다. 이 t개의 지점들은 서로 다른 위치이며 모두 s와 같지 않다.

교차로 사이에는 도로가 많아봐야 1개이다. m개의 줄 중에서 g와 h 사이의 도로를 나타낸 것이 존재한다. 또한 이 도로는 목적지 후보들 중 적어도 1개로 향하는 최단 경로의 일부이다.

# **[ 출력 ]**
테스트 케이스마다

- 입력에서 주어진 목적지 후보들 중 불가능한 경우들을 제외한 목적지들을 공백으로 분리시킨 오름차순의 정수들로 출력한다.

# **[ 예제 입력 #1 ]**
      2
      5 4 2
      1 2 3
      1 2 6
      2 3 2
      3 4 4
      3 5 3
      5
      4
      6 9 2
      2 3 1
      1 2 1
      1 3 3
      2 4 4
      2 5 5
      3 4 3
      3 6 2
      4 5 4
      4 6 3
      5 6 7
      5
      6

# **[ 예제 출력 #1 ]**
      4 5
      6

# **[ 접근 순서 ]**
1. 출발점에서 g, h 까지의 최단 거리를 구한다.
   - s -> g -> h > target
   - s -> h -> g > target
   

2. 최단거리 g, h 에서 더 먼 가까운 쪽이 second, 먼 쪽이 third 목적지로 선정된다.
   - 이유: 출발지에서 더 가까운 곳에서 이동한 후 더 먼 곳으로 이동하는게 최단거리
   

3. second 기준으로 third 를 경유해서 목적지 후보까지 가는 거리를 계산
   - ex) 시작점에서 second 까지의 거리 + second 에서 third 까지의 거리 + third 에서 목적지 까지의 거리
      - dist1[second] + dist2[third] + dist3[?]
      - ?: 목적지 노드의 번호

4. 계산한 거리가 s(출발점) 에서의 거리와 같다면 목적지이다. (최단 거리임)
   - 목적지 까지의 최단 거리가 필수 노선을 지나서 도착한 거리와 다른 케이스를 거른다.

# **[ 문제점 & 주의점 ]**
1. 최단거리가 같은 노선이 여러개 있는 경우 필수로 지나가야 하는 도로를 지나가도록 유지하게 할 방법이 필요함
   - ex) A에서 D 로 가는데 B-C 를 반드시 지나갸야 하는 경우 A - D (최단거리: 3) A - B - C - D (최단거리: 3)


2. 내가 시도한 첫 풀이 마지막으로 지나왔던 노드를 기억하는 방법
   - 마지막으로 지나온 노드가 g, h일 경우

# **[ 새로 알게된 사실 ]**
1. Ad-hoc
   - 필수로 지나가야 하는 노드에 -0.01 하여 최단거리가 같은 케이가 있다고 하더라고 무조건 적으로 지나갈 수 있게 해주는 알고리즘
   
2. 홀, 짝수
   - 필수 노선 (distance * 2 - 1) / 필수 노선 x (distance * 2)
   - 거리가 홀수 인 경우 필수 노선을 지나왔다고 판단하는 알고리즘

# **[ 결과 ]**
<img width="1153" alt="스크린샷 2023-06-03 오후 2 49 17" src="https://github.com/nashs789/CodeTest/assets/59809278/30eb3e8a-2534-45b7-86fa-45753d3070ba">
