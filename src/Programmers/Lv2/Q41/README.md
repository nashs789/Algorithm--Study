# **[ 정보 ]**
1. 소요 시간: 54분
   
         14분: 테스트 케이스 ===> 21/21                      효율성 테스트 ===> 0/5 (시간초과 5개)
         7분:  테스트 케이스 ===> 13/21 (런타임 5개, 에러 3개)   효율성 테스트 ===> 5/5
         4분:  테스트 케이스 ===> 17/21 (에러 4개)             효율성 테스트 ===> 5/5
         5분:  테스트 케이스 ===> 20/21 (에러 1개)             효율성 테스트 ===> 5/5
         10분: 테스트 케이스 ===> 성공
2. 날짜: 2023.03.06(월)
3. 저자: 이 인복
4. 난이도: Programmers(Lv2)
5. 분류: 힙   
6. 문제: 더 맵게

# **[ 문제 설명 ]**
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다.  
모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

    섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.   
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.

# **[ 제한사항 ]**
- scoville의 길이는 2 이상 1,000,000 이하입니다.
- K는 0 이상 1,000,000,000 이하입니다.
- scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
- 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

# **[ 입출력 예 ]**
    scoville	            K	    return
    [1, 2, 3, 9, 10, 12]	    7	    2

# **[ 입출력 예 설명 ]**
1. 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.   
   새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5   
   가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]


2. 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.   
   새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13   
   가진 음식의 스코빌 지수 = [13, 9, 10, 12]

모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.

# **[ 접근 순서 ]**
- PriorityQueue 없이 풀었을 때의 문제점 파악(밑에 코드 있음)
  - 매번 객체 생성하며 낭비되는 메모리 => 시간 증가
  - 정렬을 지속적으로 해줘야하는 비효율성

# **[ 문제점 & 주의점 ]**
- 정렬을 계속 하는게 비효율적으로 보임
- 계속해서 배열(객체) 생성하는게 볼륨이 크니까 시간이 많이 들어가는 것 같음

      [ 변경전 코드 ]
      테스트 결과: 테스트 케이스 ===> 21/21
                효율성 테스트 ===> 0/5 (시간초과 5개)
      public class Q {
          public static void main(String[] args) {
             int[] scoville = {1, 2, 3, 9, 10, 12};
             int K = 7;
             int answer = 0;
      
              while(true){
                  Arrays.sort(scoville);
      
                  if(scoville.length == 1 && scoville[0] < K){
                      answer = -1;
                      break;
                  }
      
                  if(Arrays.stream(scoville).anyMatch(e -> e < K)){
                      answer++;
                      int mix = scoville[0] + (scoville[1] * 2);
                      int[] newScoville = new int[scoville.length - 1];
                      newScoville[0] = mix;
      
                      for(int idx = 1; idx < newScoville.length; idx++){
                          newScoville[idx] = scoville[idx + 1];
                      }
      
                      scoville = newScoville;
                  } else {
                      break;
                  }
              }
      
              System.out.println(answer);
          }
      }


# **[ 새로 알게된 사실 ]**

# **[ 결과 ]**